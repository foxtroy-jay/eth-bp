pragma solidity ^0.5.8;
pragma experimental ABIEncoderV2;


contract Factory {

struct ReplyTweet {
    string text;
    address sender;
}    
    
struct Tweet {
        string text;
        string hashtag;
        uint blockNum;
        uint numReplies;
        mapping(uint => ReplyTweet) replies;
    }
    
struct User {
    address[] following;
    address[] follows;
    uint numTweets;
    mapping(uint => Tweet) allTweets;
}

mapping(address => User) public allUsers;
address[] public keyList;

    function createUser() public {
        address currAddress = msg.sender;

        allUsers[currAddress] = User(new address[](0), new address[](0), 0);
        keyList.push(currAddress);
    } 
    
    // function getUser(address findUser) public view returns (User memory) {
    //     return allUsers[findUser];
    // }
    
    function addStructMessage(string memory tweet, string memory hashT) public {
        User storage currUser = allUsers[msg.sender];
        uint currTweetCount = currUser.numTweets;
        
        Tweet memory newTweet = Tweet({
            text: tweet,
            hashtag: hashT,
            blockNum: block.number,
            numReplies:0
        });
        
        currUser.allTweets[currTweetCount] = newTweet;
        currUser.numTweets++;
    }
    
    function getStructMessage(address user, uint index) public view returns (string memory){
        return allUsers[user].allTweets[index].text;
    }
    
    //While creating tweets we will add button to reply with original address and index
    function addReply(address tweetor, uint index, string memory replyString) public {
         ReplyTweet memory newReply = ReplyTweet({
             text: replyString,
             sender:msg.sender
         });
        
        //Fetch number of replies to current tweet
        uint currReplyIndex = allUsers[tweetor].allTweets[index].numReplies;
        
        //Appending newReply to end of reply chain
        allUsers[tweetor].allTweets[index].replies[currReplyIndex] = newReply;
        
        //Update number of replies
        allUsers[tweetor].allTweets[index].numReplies++;
    }
    
    function getReply(address user, uint tweetIndex, uint replyIndex) public view returns (string memory) {
        return allUsers[user].allTweets[tweetIndex].replies[replyIndex].text;
    }
}




  
//  function getAllUsersIndex() public view returns (User[] memory){
//      return allUsers[msg.sender];
// }


  
// function addStructMessage(string memory tweet) public {

//     mappingTest[msg.sender].push(Entry(tweet));
// }

// function checkStructMessage(uint index) public view returns (string memory){
//     return mappingTest[msg.sender][index].text;
// }


//   function getMessageLength() public view returns (uint){
//       return tweets[msg.sender].length;
//   }

//   function getKeys() public view returns (address[] memory) {
//         return keyList;

//   }


// contract NEWUser {
//     constructor (address creator) public{
//         address manager = creator;
//     }
    
    
//     Tweet[] public allTweets;
//     address[] following;
//     address[] follows;
//     uint numTweets;    
        
//     // function setMessage(string memory newMessage) public {
//     //     allTweets.push(newMessage);
//     // }
    
//     function addStructTweet(string memory tweet) public {
//     //block.timeStamp or now will both return blocktime in uint
//         allTweets[numTweets] = Tweet(tweet,'',block.number);
//         numTweets++;
//     }
    
//     //same as calling from allTweets
//     function getMessageByIndex(uint index) public view returns (string memory) {
//         return allTweets[index].text;
//     }
  
//     // function fetchUserTweets(address user) public view returns (string[] memory) {
//     //     return allTweets;
//     // }
// }
